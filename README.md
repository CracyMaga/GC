# GC
# Unity中的GC以及优化
## Unity GC分析及优化
### 介绍
<td style="text-align: center">
  <img src="https://github.com/CracyMaga/GC/blob/main/GC.png" width="1300"/>
</td>


在游戏运行的时候，数据主要存储在内存中，当游戏的数据不在需要的时候，存储当前数据的内存就可以被回收再次使用。内存垃圾是指当前废弃数据所占用的内存，垃圾回收（GC）是指将废弃的内存重新回收再次使用的过程。Unity中将垃圾回收当作内存管理的一部分，如果游戏中垃圾回收十分复杂，则游戏的性能会受到极大影响，此时垃圾回收会成为游戏性能的一大障碍点。

### Unity内存管理机制简介
要想了解垃圾回收如何工作以及何时被触发，我们首先需要了解unity的内存管理机制。Unity主要采用自动内存管理的机制，开发时在代码中不需要详细地告诉unity如何进行内存管理，unity内部自身会进行内存管理。

unity的自动内存管理可以理解为以下几个部分：

1、unity内部有两个内存管理池：堆内存和堆栈内存。堆栈内存(stack)主要用来存储较小的和短暂的数据片段，堆内存(heap)主要用来存储较大的和存储时间较长的数据片段。
unity中的变量只会在堆栈或者堆内存上进行内存分配。

2、只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态，变量要么存储在堆栈内存上，要么处于堆内存上。

3、一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于堆栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，其对应的内存依然会被标记为使用状态。

垃圾回收主要是指堆上的内存分配和回收，unity中会定时对堆内存进行GC操作。

在了解了GC的过程后，下面详细了解堆内存和堆栈内存的分配和回收机制的差别。 

### 栈内存分配和回收机制
栈上的内存分配和回收十分快捷简单，主要是栈上只会存储短暂的较小的变量。内存分配和回收都会以一种可控制顺序和大小的方式进行。

栈的运行方式就像 stack :只是一个数据的集合，数据的进出都以一种固定的方式运行。正是这种简洁性和固定性使得堆栈的操作十分快捷。当数据被存储在栈上的时候，只需要简单地在其后进行扩展。当数据失效的时候，只需要将其从栈上移除复用。

### 堆内存分配和回收机制

堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。

堆上的变量在存储的时候，主要分为以下几步：

1、unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应的内存单元；

2、如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够的内存单元，则进行内存分配。

3、如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应的内存单元给变量。

堆内存的分配有可能会变得十分缓慢，特别是需要垃圾回收和堆内存需要扩展的情况下。

### 垃圾回收时的操作

当一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。

每次运行GC的时候，主要进行下面的操作：

1、GC会检查堆内存上的每个存储变量；

2、对每个变量会检测其引用是否处于激活状态；

3、如果变量的引用不再处于激活状态，则会被标记为可回收；

4、被标记的变量会被移除，其所占有的内存会被回收到堆内存上。

GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。

### 何时会触发垃圾回收

主要有三个操作会触发垃圾回收：

1、在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；

2、GC会自动的触发，不同平台运行频率不一样；

3、GC可以被强制执行。

GC操作可以被频繁触发，特别是在堆内存上进行内存分配时内存单元不足够的时候，这就意味着频繁在堆内存上进行内存分配和回收会触发频繁的GC操作。

### GC操作带来的问题

在了解GC在unity内存管理中的作用后，我们需要考虑其带来的问题。最明显的问题是GC操作会需要大量的时间来运行，如果堆内存上有大量的变量或者引用需要检查，则检查的操作会十分缓慢，这就会使得游戏运行缓慢。其次GC可能会在关键时候运行，例如CPU处于游戏的性能运行关键时刻，其他的任何一个额外的操作都可能会带来极大的影响，使得游戏帧率下降。

另外一个GC带来的问题是堆内存碎片。当一个内存单元从堆内存上分配出来，其大小取决于其存储的变量的大小。当该内存被回收到堆内存上的时候，有可能使得堆内存被分割成碎片化的单元。也就是说堆内存总体可以使用的内存单元较大，但是单独的内存单元较小，在下次内存分配的时候不能找到合适大小的存储单元，这就会触发GC操作或者堆内存扩展操作。

堆内存碎片会造成两个结果，一个是游戏占用的内存会越来越大，一个是GC会更加频繁地被触发。

### 分析GC带来的问题

GC操作带来的问题主要表现为帧率运行低，性能间歇中断或者降低。如果游戏有这样的表现，则首先需要打开unity中的profiler window来确定是否是GC造成。

### 分析堆内存的分配

如果GC造成游戏的性能问题，我们需要知道游戏中的哪部分代码会造成GC，内存垃圾在变量不再激活的时候产生，所以首先我们需要知道堆内存上分配的是什么变量。

#### 堆内存和堆栈内存分配的变量类型

在Unity中，值类型变量都在堆栈上进行内存分配，其他类型的变量都在堆内存上分配。如果你不知道值类型和引用类型的差别，可以查看此处。

下面的代码可以用来理解值类型的分配和释放,其对应的变量在函数调用完后会立即回收：

```csharp

void ExampleFunciton()
{
    int localInt = 5;  
}

```
对应的引用类型的参考代码如下，其对应的变量在GC的时候才回收：

```csharp
void ExampleFunction()
{
    List localList = new List();      
}
```
#### 利用profiler window 来检测堆内存分配：

我们可以在profier window中检查堆内存的分配操作：在CPU usage分析窗口中，我们可以检测任何一帧cpu的内存分配情况。其中一个选项是GC alloc，通过分析其来定位是什么函数造成大量的堆内存分配操作。一旦定位该函数，我们就可以分析解决其造成问题的原因从而减少内存垃圾的产生。

### 降低GC的影响的方法

大体上来说，我们可以通过三种方法来降低GC的影响：

1、减少GC的运行次数；

2、减少单次GC的运行时间；

3、将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC

基于此，我们可以采用三种策略：

1、对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。

2、降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存碎片。

3、我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响。

### 减少内存垃圾的数量


